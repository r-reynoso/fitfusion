import 'package:cloud_firestore/cloud_firestore.dart';

/// FitFusion Firestore Data Schema
/// 
/// This file defines the complete data schema for the FitFusion Firebase project.
/// All collections, documents, and their fields are documented here for reference.

class FirestoreDataSchema {
  
  /// USERS COLLECTION
  /// Collection: 'users'
  /// Purpose: Store user authentication and profile data for both trainers and clients
  /// 
  /// Document ID: Firebase Auth UID
  /// Fields:
  static const usersCollection = 'users';
  static final usersSchema = {
    'email': 'string',           // Required - User's email address
    'role': 'string',            // Required - 'trainer' or 'client'
    'name': 'string',            // Required - User's full name
    'phone': 'string?',          // Optional - Phone number
    'specialization': 'string?', // Optional - Trainer's specialization (trainers only)
    'experienceYears': 'int?',   // Optional - Years of experience (trainers only)
    'trainerId': 'string?',      // Optional - Associated trainer ID (clients only)
    'createdAt': 'TIMESTAMP',    // Auto - Document creation timestamp
    'updatedAt': 'TIMESTAMP',    // Auto - Last update timestamp
  };

  /// CLIENTS COLLECTION
  /// Collection: 'clients'
  /// Purpose: Store additional client-specific information and metrics
  /// 
  /// Document ID: Client's Firebase Auth UID (same as users collection)
  /// Fields:
  static const clientsCollection = 'clients';
  static final clientsSchema = {
    'userId': 'string',          // Required - Reference to user document
    'trainerId': 'string',       // Required - Associated trainer's UID
    'metrics': 'object',         // Required - Client's physical metrics (see ClientMetrics)
    'createdAt': 'TIMESTAMP',    // Auto - Document creation timestamp
    'updatedAt': 'TIMESTAMP',    // Auto - Last update timestamp
  };

  /// CLIENT METRICS SUB-OBJECT
  /// Nested within clients.metrics field
  /// Purpose: Store client's physical measurements and goals
  static final clientMetricsSchema = {
    'weight': 'double',          // Required - Client's weight
    'height': 'double',          // Required - Client's height
    'age': 'int',               // Required - Client's age
    'goals': 'string?',         // Optional - Client's fitness goals
    'gender': 'string?',        // Optional - Client's gender
    'updatedAt': 'TIMESTAMP',    // Auto - Last metrics update
  };

  /// ROUTINES COLLECTION
  /// Collection: 'routines'
  /// Purpose: Store workout routines created by trainers for clients
  /// 
  /// Document ID: Auto-generated by Firestore
  /// Fields:
  static const routinesCollection = 'routines';
  static final routinesSchema = {
    'clientId': 'string',        // Required - Client's UID this routine is for
    'trainerId': 'string',       // Required - Trainer's UID who created this
    'title': 'string',           // Required - Routine title/name
    'days': 'array',            // Required - Array of RoutineDay objects
    'notes': 'string?',         // Optional - General notes for the routine
    'isPublic': 'bool',         // Required - Whether routine is publicly shareable
    'publicToken': 'string?',   // Optional - Secure token for public sharing
    'publicExpiresAt': 'TIMESTAMP?', // Optional - Expiration for public sharing
    'createdAt': 'TIMESTAMP',   // Auto - Document creation timestamp
    'updatedAt': 'TIMESTAMP',   // Auto - Last update timestamp
  };

  /// ROUTINE DAY OBJECT STRUCTURE
  /// Nested within routines.days array
  /// Purpose: Represents a single day in a workout routine
  static final routineDaySchema = {
    'day': 'string',            // Required - Day name (e.g., 'Monday', 'Day 1')
    'items': 'array',           // Required - Array of RoutineItem objects (exercises and dividers)
    'exercises': 'array',       // Deprecated - Kept for backward compatibility
  };

  /// ROUTINE ITEM OBJECTS
  /// Nested within routineDay.items array
  /// Purpose: Represents exercises and dividers in a workout day
  
  /// Exercise Object:
  static final exerciseSchema = {
    'type': 'exercise',         // Required - Item type identifier
    'name': 'string',           // Required - Exercise name
    'reps': 'string',           // Required - Number of reps or duration
    'sets': 'string',           // Required - Number of sets
    'notes': 'string?',         // Optional - Exercise-specific notes
  };

  /// Divider Object:
  static final dividerSchema = {
    'type': 'divider',          // Required - Item type identifier
    'label': 'string?',         // Optional - Divider label/title
  };

  /// PUBLIC SHARES COLLECTION (Optional - for enhanced public sharing)
  /// Collection: 'publicShares'
  /// Purpose: Track public routine shares and access analytics
  /// 
  /// Document ID: Auto-generated by Firestore
  /// Fields:
  static const publicSharesCollection = 'publicShares';
  static final publicSharesSchema = {
    'routineId': 'string',      // Required - Reference to routine document
    'trainerId': 'string',      // Required - Trainer who shared the routine
    'token': 'string',          // Required - Public access token
    'expiresAt': 'TIMESTAMP?',  // Optional - Expiration timestamp
    'accessCount': 'int',       // Required - Number of times accessed
    'createdAt': 'TIMESTAMP',   // Auto - Document creation timestamp
    'lastAccessedAt': 'TIMESTAMP?', // Optional - Last access timestamp
  };

  /// ANALYTICS COLLECTION (Future Enhancement)
  /// Collection: 'analytics'
  /// Purpose: Store usage analytics and metrics for trainers
  /// 
  /// Document ID: Auto-generated by Firestore
  /// Fields:
  static const analyticsCollection = 'analytics';
  static final analyticsSchema = {
    'trainerId': 'string',      // Required - Trainer's UID
    'type': 'string',           // Required - Analytics event type
    'data': 'object',           // Required - Event-specific data
    'timestamp': 'TIMESTAMP',   // Auto - Event timestamp
  };

  /// SECURITY RULES SUMMARY
  /// 
  /// Users Collection:
  /// - Users can read/write their own data
  /// - Trainers can read their clients' user data
  /// 
  /// Clients Collection:
  /// - Trainers can read/write their own clients
  /// - Clients can read their own data
  /// 
  /// Routines Collection:
  /// - Trainers can read/write their own routines
  /// - Clients can read routines assigned to them
  /// - Public routines can be read by anyone
  /// 
  /// Public Shares Collection:
  /// - Anyone can read public shares
  /// - Only authenticated users can create shares
  /// 
  /// Analytics Collection:
  /// - Trainers can only read/write their own analytics

  /// FIRESTORE INDEXES SUMMARY
  /// 
  /// Composite Indexes Required:
  /// 1. routines: trainerId (ASC) + updatedAt (DESC)
  /// 2. routines: clientId (ASC) + updatedAt (DESC) 
  /// 3. routines: isPublic (ASC) + publicExpiresAt (ASC)
  /// 4. clients: trainerId (ASC) + createdAt (DESC)
  /// 5. users: role (ASC) + name (ASC) - for trainer listings
  /// 6. routines: publicToken (ASC) + isPublic (ASC) - for public access
  /// 
  /// Single-field indexes are automatically managed by Firestore

  /// QUERY PATTERNS SUMMARY
  /// 
  /// Common queries this schema supports:
  /// - Get user by UID: users/{uid}
  /// - Get trainers: users.where('role', '==', 'trainer').orderBy('name')
  /// - Get trainer's clients: clients.where('trainerId', '==', uid)
  /// - Get trainer's routines: routines.where('trainerId', '==', uid).orderBy('updatedAt', 'desc')
  /// - Get client's routines: routines.where('clientId', '==', uid).orderBy('updatedAt', 'desc')
  /// - Get public routine: routines.where('publicToken', '==', token).where('isPublic', '==', true)
  /// - Search routines: routines.where('title', '>=', query).where('title', '<', query + 'z')

  /// DATA VALIDATION RULES
  /// 
  /// Users:
  /// - email: Must be valid email format
  /// - role: Must be 'trainer' or 'client'
  /// - name: Must not be empty
  /// - phone: Optional, validate format if provided
  /// 
  /// Clients:
  /// - userId: Must match document ID
  /// - trainerId: Must exist in users collection as trainer
  /// - metrics.weight/height/age: Must be positive numbers
  /// 
  /// Routines:
  /// - clientId/trainerId: Must exist in users collection
  /// - title: Must not be empty
  /// - days: Must not be empty array
  /// - publicToken: Must be unique if provided

  /// MIGRATION NOTES
  /// 
  /// From Demo to Production:
  /// 1. All demo data will be replaced with real Firebase data
  /// 2. Users must re-register (no migration path from demo)
  /// 3. Firestore security rules enforce proper access control
  /// 4. All timestamps use Firestore server timestamps
  /// 5. Document IDs use Firebase Auth UIDs for consistency

  /// BACKUP AND DISASTER RECOVERY
  /// 
  /// Recommendations:
  /// 1. Enable automated backups in Firebase Console
  /// 2. Export critical data regularly using Admin SDK
  /// 3. Test restoration procedures in development environment
  /// 4. Monitor usage and set up billing alerts
  /// 5. Use Firebase Emulator Suite for development/testing

  /// PERFORMANCE OPTIMIZATION
  /// 
  /// Best Practices Implemented:
  /// 1. Proper indexing for all query patterns
  /// 2. Paginated queries with limit() and pagination
  /// 3. Batch operations for multiple writes
  /// 4. Transaction usage for consistency requirements
  /// 5. Minimal data transfer with field selection where possible
}

/// Helper class for Firestore operations
class FirestoreHelper {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Get a reference to a collection
  static CollectionReference collection(String collectionName) {
    return _firestore.collection(collectionName);
  }

  /// Get a reference to a document
  static DocumentReference document(String collectionName, String documentId) {
    return _firestore.collection(collectionName).doc(documentId);
  }

  /// Create a batch for multiple operations
  static WriteBatch batch() {
    return _firestore.batch();
  }

  /// Run a transaction
  static Future<T> runTransaction<T>(
    Future<T> Function(Transaction transaction) updateFunction,
  ) {
    return _firestore.runTransaction(updateFunction);
  }

  /// Server timestamp for consistent time across all documents
  static FieldValue get serverTimestamp => FieldValue.serverTimestamp();

  /// Delete field value
  static FieldValue get deleteField => FieldValue.delete();

  /// Array union operation
  static FieldValue arrayUnion(List elements) => FieldValue.arrayUnion(elements);

  /// Array remove operation
  static FieldValue arrayRemove(List elements) => FieldValue.arrayRemove(elements);

  /// Increment numeric field
  static FieldValue increment(num value) => FieldValue.increment(value);
}